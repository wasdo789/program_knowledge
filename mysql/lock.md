mysql在RU(未提交读)隔离级别下，都是读取当前数据，不需要锁。以下默认是度提交隔离级别的讨论

- 加锁对象：
mysql锁是加在索引上的，如果没有任何索引，会默认创建一个聚簇索引。如果一个操作访问多个索引，会对多个索引同时加锁
- 锁的分类：
	1. 按照范围，常见的有：记录锁（行锁），间隙锁（gap lock），表锁（意向锁或者元数据锁），全局锁。
	2. 按照读写类型。S共享锁，X互斥锁。间隙锁没有共享互斥之分。
	3. 意向锁。包括普通意向锁。和插入意向锁（是一种特殊的间隙锁）。普通意向锁分为X和S另种
邻间锁（next key lock）实质是间隙锁加行锁，是逻辑意义上的，这里不作讨论
- 锁的产生条件：
	1. 记录锁。操作的记录存在，并且是当前读（使用for share或者for update) 和写操作，写操作包括insert，update，delete。如果操作的记录存在，则不会有记录锁（看似废话，实则容易忽略）。如果访问多个索引，则会对所有索引记录都产生记录锁。
	2. 间隙锁。在RR（可重复读）隔离级别下。当前读或者update和delete，非唯一键等值条件下（范围操作或者非唯一键等值）产生。注意insert操作不会产生间隙锁，会产生插入意向锁这种特殊的间隙锁，后续说明原因。
	3. 普通意向锁。分为S共享锁和X互斥锁。在当前读和写操作时产生
	4. 插入意向锁。在insert操作时产生
- 不同锁的设计目的
	1. 记录锁，保护同一行数据的互斥访问
	2. 间隙锁，锁住一个间隙。解决幻度问题。假设只有记录锁，那如果记录不存在，不会锁住任何对象，就可以插入该条记录，产生幻度。有了间隙锁之后，如果记录不存在，可以锁住索引间隙，就可以禁止后续对该区间的插入操作。多个间隙锁不冲突。和插入操作（或者说和插入意向锁冲突）操作区间重合情况下。注意和删除、更新操作其实不冲突（没有记录锁的情况下，比如锁住的区间没有数据）。
	3. 插入意向锁。如果insert操作也产生普通的间隙锁，比如事物T1插入索引字段2，T2插入索引字段3，但是可能产生同一个间隙锁，比如（0,5）。那么T2就必须等T1释放（0.5）的间隙锁才能继续，实际上由于操作的是不同的记录，如果能够并行，性能就大大提升。因此引入插入意向锁，T1插入时，产生插入意向锁（0,5），不会阻塞T2的插入操作，T2也会产生插入意向锁（0,5）。因此插入意向锁是为了解决并发插入性能低的问题的
	4. 意向锁，表级锁。如果某个操作可能会产生S或者X记录锁，mysql server层会首先在表上加意向锁（即使记录不存在也会）。 分为S和X。是为了调和行锁和表锁的。意向锁和表锁冲突，比如元数据锁MDL或者lock table的表锁。如果没有意向锁，那么加表级别的锁时，会检查所有记录是否有锁，这样性能极低。有意向锁后，只需要检查有意向锁即可。多个意向锁不冲突
	不同操作产生的锁：
		1. 普通读 select。。，不会产生锁
		2. 当前读 select...in share mode。可能产生S记录锁、间隙锁、S意向锁
		3. 当前读select...for update。可能产生X记录锁，间隙锁，X意向锁
		4. insert。可能产生X记录锁，插入意向锁，X意向锁
		5. update、delete。可能产生X记录所有，间隙锁，X意向锁
		6. lock table read/write，产生S/X表锁
		7. 表结构更改语句，产生MDL，表级锁



